{
  
    
        "post0": {
            "title": "Image Formats",
            "content": "File Information . MAC Windows . | | . import cv2 import numpy as np from PIL import Image import matplotlib.pyplot as plt . OpenCV . To read a sample image, and reading its properties like height, width, and channels. . Reads in BGR format | shape is for finding the size of image | rows, column, and channel are returned from shape | rows means height, column means width, channels : 3 for color or 1 for Grayscale | . img = cv2.imread(&quot;image_formats/test.png&quot;) . Row,Column,Channel = img.shape . print(&quot;Rows = &quot;, Row, &quot;Columns = &quot;, Column) . Rows = 534 Columns = 800 . print(&quot;Height = &quot;, Row, &quot;Width = &quot;, Column, &quot;Channels = &quot;, Channel) . Height = 534 Width = 800 Channels = 3 . PIL . Reads in RGB format | size is for finding the size of image | column and rows are returned from size | rows means height, column means width | mode is string which defines the type and depth of a pixel in image | . img_pil = Image.open(&quot;image_formats/test.png&quot;) . 1 (1-bit pixels, black and white, stored with one pixel per byte) | L (8-bit pixels, black and white) | RGB (3x8-bit pixels, true color) | RGBA (4x8-bit pixels, true color with transparency mask) | CMYK (4x8-bit pixels, color separation) | HSV (3x8-bit pixels, Hue, Saturation, Value color space) | . img_pil.mode . &#39;RGB&#39; . Column,Row = img_pil.size . print(&quot;Rows = &quot;, Row, &quot;Columns = &quot;, Column) . Rows = 534 Columns = 800 . Numpy . Using OpenCV . png_np_img = np.asarray(img) plt.imshow(png_np_img) # if its grayscale plt.imshow(png_np_img, cmap=&#39;gray&#39;) # Showing the np characteritics print(&quot;shape is &quot;, png_np_img.shape) print(&quot;dtype is &quot;, png_np_img.dtype) print(&quot;ndim is &quot;, png_np_img.ndim) print(&quot;itemsize is &quot;, png_np_img.itemsize) # size in bytes of each array element print(&quot;nbytes is &quot;, png_np_img.nbytes) # size in bytes of each array element . shape is (534, 800, 3) dtype is uint8 ndim is 3 itemsize is 1 nbytes is 1281600 . Using PIL . png_np_img = np.asarray(img_pil) plt.imshow(png_np_img) # this will graphit in a jupyter notebook # or if its grayscale plt.imshow(png_np_img, cmap=&#39;gray&#39;) # FWIW, this will show the np characteritics print(&quot;shape is &quot;, png_np_img.shape) print(&quot;dtype is &quot;, png_np_img.dtype) print(&quot;ndim is &quot;, png_np_img.ndim) print(&quot;itemsize is &quot;, png_np_img.itemsize) # size in bytes of each array element print(&quot;nbytes is &quot;, png_np_img.nbytes) # size in bytes of each array element . shape is (534, 800, 3) dtype is uint8 ndim is 3 itemsize is 1 nbytes is 1281600 . Access Pixel . Using GIMP, the coordinate system (x,y) is defined as below | . . At (600,100) in GIMP we have following R,G,B values (21,131,172) | . . Using OpenCV . Uses BGR format | Accesses using row first, then column | The format (X,Y) -&gt; (600,100) or (ROW,COL) -&gt; (100,600) | . row = 100 col = 600 pixel_b, pixel_g, pixel_r = img[row][col] print(&quot;BGR values = &quot;, pixel_b, pixel_g, pixel_r) . BGR values = 172 131 21 . Using PIL . Uses RGB format | Accesses using column first, then row | The format (X,Y) -&gt; (600,100) or (COL,ROW) -&gt; (600,100) | . row = 100 col = 600 pixel_r, pixel_g, pixel_b = img_pil.getpixel((col,row)) print(&quot;BGR values = &quot;, pixel_b, pixel_g, pixel_r) . BGR values = 172 131 21 . Using Numpy . Uses RGB/BGR depending on input | Accesses using row first, then column for all formats | The format (X,Y) -&gt; (600,100) or (ROW,COL) -&gt; (100,600) | . row = 100 col = 600 pixel_b, pixel_g, pixel_r = np.array(img)[row,col] print(&quot;BGR values = &quot;, pixel_b, pixel_g, pixel_r) . BGR values = 172 131 21 . row = 100 col = 600 pixel_r, pixel_g, pixel_b = np.array(img_pil)[row,col] print(&quot;BGR values = &quot;, pixel_b, pixel_g, pixel_r) . BGR values = 172 131 21 . Channels . Using OpenCV . b,g,r = cv2.split(img) . f, axarr = plt.subplots(2,2) axarr[0,0].imshow(img) axarr[0,1].imshow(b) axarr[1,0].imshow(g) axarr[1,1].imshow(r) . &lt;matplotlib.image.AxesImage at 0x15f9b7f70&gt; . Using PIL . r,g,b = img_pil.split() #r = img.getchannel(0) #g = img.getchannel(1) #b = img.getchannel(2) . f, axarr = plt.subplots(2,2) axarr[0,0].imshow(img_pil) axarr[0,1].imshow(b) axarr[1,0].imshow(g) axarr[1,1].imshow(r) . &lt;matplotlib.image.AxesImage at 0x15fc4b880&gt; . Using Numpy . arr = np.array(img_pil) r = arr[:,:,0] g = arr[:,:,1] b = arr[:,:,2] . f, axarr = plt.subplots(2,2) axarr[0,0].imshow(arr) axarr[0,1].imshow(b) axarr[1,0].imshow(g) axarr[1,1].imshow(r) . &lt;matplotlib.image.AxesImage at 0x16000c8e0&gt; . arr = np.array(img) b = arr[:,:,0] g = arr[:,:,1] r = arr[:,:,2] . f, axarr = plt.subplots(2,2) axarr[0,0].imshow(arr) axarr[0,1].imshow(b) axarr[1,0].imshow(g) axarr[1,1].imshow(r) . &lt;matplotlib.image.AxesImage at 0x160146fd0&gt; . Arrangement . Column major matrix . Height X Width X Channel | Each sample is stored as a column-major matrix (height, width) of float[Channels] (b00, g00, r00, b10, g10, r10, b01, g01, r01, b11, g11, r11). | . Offset (byte) : 0 1 2 3 4 5 6 7 8 ...29 30 31 32 33 34 35 36 37 ... Height Pos : 0 0 0 0 0 0 0 0 0 ... 0 0 0 1 1 1 1 1 1 ... Width Pos : 0 0 0 1 1 1 2 2 2 ... 9 9 9 0 0 0 1 1 1 ... Color Index : B G R B G R B G R ... B G R B G R B G R ... . Row major matrix . Channel X Height X Width | Each sample is stored as a row-major matrix of float[Channels] of (height, width) (b00, b10, b01, b11, g00, g10, g01, g11, r00, r10, r01, r11). | . Offset (byte) : 0 1 2 3 ... 9 10 11 12 13 ...90 91 92 93 ... 99 100 ... 199 200 ... 299 Color Index : B B B B ... B B B B B ... B B B B ... B G ... G R ... R Height Pos : 0 0 0 0 ... 0 0 0 0 0 ... 9 9 9 9 ... 9 0 ... 9 0 ... 9 Width Pos : 0 1 2 3 ... 9 0 1 2 3 ... 0 1 2 3 ... 9 0 ... 9 0 ... 9 . Tensorrt Cudnn Format . // -- // ConvolutionNode (convolutionWeights, inputFeature) // -- . // Convolutions (incl. pooling) support two different storage formats: // // legacy (&quot;HWC&quot;) mode (CPU and GPU without cudnn): Channels are tuples of scalars // // Each sample is stored as a column-major matrix (height, width) of float[numChannels] (r00, g00, b00, r10, g10, b10, r01, g01, b01, r11, g11, b11). // // - input : [C x W x H x T] or ARRAY[1..T] OF ARRAY[1..H] OF ARRAY[1..W] OF ARRAY[1..C] // - output : [C&#39; x W&#39; x H&#39; x T] or ARRAY[1..T] OF ARRAY[1..H&#39;] OF ARRAY[1..W&#39;] OF ARRAY[1..C&#39;] // - filter : [C&#39; x W&quot; x H&quot; x C ] or ARRAY[1..C] OF ARRAY[1..H&quot;] OF ARRAY[1..W&quot;] OF ARRAY[1..C&#39;] // // cudnn (&quot;CHW&quot;) mode (GPU only): Channels are planes // // - input : [W x H x C x T] or ARRAY[1..T] OF ARRAY[1..C] OF ARRAY[1..H] OF ARRAY[1..W] // - output : [W&#39; x H&#39; x C&#39; x T] or ARRAY[1..T] OF ARRAY[1..C&#39;] OF ARRAY[1..H&#39;] OF ARRAY[1..W&#39;] // - filter : [W&quot; x H&quot; x C xC&#39;] or ARRAY[1..C&#39;] OF ARRAY[1..C] OF ARRAY[1..H] OF ARRAY[1..W] // // where: // - using &#39; for output and &quot; for filter // - T = samples (NVidia calls this N) // - W, H = width, height (W&#39;, H&#39; for output, W&quot;, H&quot; for kernel) // - C = input channels // - 3 for color images, 1 for B&amp;W images // - for hidden layer: dimension of activation vector for each pixel // - C&#39; = output channels = dimension of activation vector for each pixel .",
            "url": "https://princep.github.io/opencv/pil/tensorrt/python/2022/09/03/Image-Formats.html",
            "relUrl": "/opencv/pil/tensorrt/python/2022/09/03/Image-Formats.html",
            "date": " • Sep 3, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Bazel: Building for C++, Android and IOS",
            "content": "Introduction . Bazel is a tool for building and testing applications. The same thing can be performed by Make, CMakelists or Gradle. What makes Bazel different? It can develop application for different platforms, with different codebases and is highly parallel. The largest repos are built mostly with Bazel now. . Installation . Download and install Bazel. . Terminologies . Workspace . The main directory of the project from where all the sources files are accessible. A workspace is made when bazel finds a WORKSPACE or WORKSPACE.bazel file. . # Here repo is the workspace and contains WORKSPACE file repo/src/module1/BUILD repo/src/module1/runner1.cc repo/src/module2/BUILD repo/src/module2/runner2.cc repo/src/tests/data/cases.txt repo/src/tests/BUILD repo/src/tests/pass.py repo/WORKSPACE . Repositories . The directory containing the WORKSPACE file, is also called as @. We can also have several external repositories for a project. . # Here @repo can be seen as a repository repo/src/module1/BUILD repo/src/module1/runner1.cc repo/src/module2/BUILD repo/src/module2/runner2.cc repo/src/tests/data/cases.txt repo/src/tests/BUILD repo/src/tests/pass.py repo/WORKSPACE . Packages . All related files for a particular task in the source directory are called as packages. Each package is defined by BUILD file. . # Here module1, module2 and tests are defined as packages, Not data repo/src/module1/BUILD repo/src/module1/runner1.cc repo/src/module2/BUILD repo/src/module2/runner2.cc repo/src/tests/data/cases.txt repo/src/tests/BUILD repo/src/tests/pass.py repo/WORKSPACE . Targets and Labels . Contents of the package are called as targets. The contents can be files or rules(defined later). The files can be source files(code files) or generated files(.o/.pyc/.osx/.exe etc). . The name of the target is called as label. Each label is uniquely pointing to a target. So given the previous example, we can have following targets. . @repo//src/module1:runner1 . @repo//src/module2:runner2 . @repo//src/tests:pass . @repo//src/tests:data/cases.txt . The naming also allows //src/tests:pass if we are inside repo folder. For external repositories, the name should be given in full. . All naming conventions are standard in the above cases i.e. (//,.,..,) are not allowed as names of either package or target. They all should be meaningful in nature. . Rules . It is way to generate outputs from the given inputs. Now for each language we have different rules. For C/C++, we have cc_binary rule. For python, we have py_binary rule. So we have given rules for each file. . # runner1 is a C++ file, dependencies are defined in deps cc_binary( name = &quot;runner1&quot;, srcs = [&quot;runner1.cc&quot;], deps = [ &quot;//absl/base&quot;, &quot;//absl/strings&quot;, ], ) . BUILD files . The build file is comparised of following sections. . Extensions . Use the load statement, to import something which can be a particular rule, symbol or constant. . load(&quot;//src/custom:file.bzl&quot;, &quot;custom_package&quot;) . Rules . All the standard available rules are given here. . Dependencies . srcs Files or rules | deps Symbols, libraries, generated files | data txt,image,audio etc | . Bazel commands . bazel --version -&gt; gives version bazel build &lt;labels&gt; -&gt; builds the package bazel-bin/&lt;label-names&gt;/&lt;target&gt; -&gt; executes the package bazel query --notool_deps --noimplicit_deps &quot;deps(&lt;target&gt;)&quot; --output graph --&gt; generates the graph .",
            "url": "https://princep.github.io/bazel/2021/01/22/Bazel.html",
            "relUrl": "/bazel/2021/01/22/Bazel.html",
            "date": " • Jan 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://princep.github.io/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://princep.github.io/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}